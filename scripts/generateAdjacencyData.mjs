#!/usr/bin/env node
/**
 * Generate src/utils/adjacencyValidation.js from the consensus adjacency CSV
 * and per-modality tool_to_subsection_map.json files.
 *
 * Usage: node scripts/generateAdjacencyData.mjs
 */
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const root = path.resolve(__dirname, '..');

// 1. Parse adjacency matrix → sparse edge list
const csvPath = path.join(root, 'utils/consensus_connects/consensus_tool_adjacency_matrix.csv');
const csv = fs.readFileSync(csvPath, 'utf8');
const rows = csv.replace(/\r/g, '').trim().split('\n').map(r => r.split(','));
const header = rows[0].slice(1);

const edges = {};
for (let i = 1; i < rows.length; i++) {
    const src = rows[i][0];
    const targets = [];
    for (let j = 1; j < rows[i].length; j++) {
        if (rows[i][j].trim() === '1') targets.push(header[j - 1]);
    }
    if (targets.length) edges[src] = targets;
}

// 2. Parse subsection maps → tool metadata
const mapFiles = [
    'utils/amico_tests/connects/amico_tool_to_subsection_map.json',
    'utils/asl_tests/connects/asl_tool_to_subsection_map.json',
    'utils/dmri_tests/connects/dmri_tool_to_subsection_map.json',
    'utils/fmri_tests/connects/fmri_tool_to_subsection_map.json',
    'utils/mm_tests/connects/mm_tool_to_subsection_map.json',
    'utils/pet_tests/connects/pet_tool_to_subsection_map.json',
    'utils/structural_mri_tests/connects/structural_mri_tool_to_subsection_map.json',
    'utils/utils_tests/connects/utils_tool_to_subsection_map.json',
];

const toolMeta = {};
for (const f of mapFiles) {
    const data = JSON.parse(fs.readFileSync(path.join(root, f), 'utf8'));
    const mod = data.modality;
    for (const [tool, info] of Object.entries(data.byTool || {})) {
        if (!toolMeta[tool]) {
            toolMeta[tool] = { modality: mod, subsection: info.subsection };
        } else {
            toolMeta[tool].modality2 = mod;
        }
    }
}

// 3. Build JS source
const edgeLines = Object.entries(edges).sort().map(([src, targets]) => {
    const t = targets.map(x => JSON.stringify(x)).join(', ');
    return `    ${JSON.stringify(src)}: [${t}]`;
});

const metaLines = Object.entries(toolMeta).sort().map(([tool, info]) => {
    const mod = info.modality2 ? `${info.modality}/${info.modality2}` : info.modality;
    return `    ${JSON.stringify(tool)}: [${JSON.stringify(mod)}, ${JSON.stringify(info.subsection)}]`;
});

const output = `/**
 * Edge validation using the consensus tool adjacency matrix.
 *
 * Auto-generated by scripts/generateAdjacencyData.mjs — do not edit manually.
 *
 * Data sourced from:
 *   utils/consensus_connects/consensus_tool_adjacency_matrix.csv
 *   utils/{modality}_tests/connects/{modality}_tool_to_subsection_map.json
 *
 * VALID_EDGES: sparse map of source -> allowed targets (${Object.values(edges).reduce((s, v) => s + v.length, 0)} edges across ${Object.keys(edges).length} sources).
 * TOOL_META: tool -> [modality, subsection] for human-readable messages.
 */

const VALID_EDGES = {
${edgeLines.join(',\n')}
};

const TOOL_META = {
${metaLines.join(',\n')}
};

// Precompute Set-based lookup for O(1) edge checks
const _edgeSets = new Map();
for (const [src, targets] of Object.entries(VALID_EDGES)) {
    _edgeSets.set(src, new Set(targets));
}

/**
 * Check whether a directed tool connection is valid per the consensus matrix.
 * Returns true for any connection involving unknown tools (not in the matrix).
 */
export function isValidToolConnection(sourceLabel, targetLabel) {
    if (!sourceLabel || !targetLabel) return true;
    if (!TOOL_META[sourceLabel] || !TOOL_META[targetLabel]) return true;
    const allowed = _edgeSets.get(sourceLabel);
    return allowed ? allowed.has(targetLabel) : false;
}

/**
 * Return a human-readable reason why a connection is invalid.
 * Returns null if the connection is valid or involves unknown tools.
 */
export function getInvalidConnectionReason(sourceLabel, targetLabel) {
    if (isValidToolConnection(sourceLabel, targetLabel)) return null;

    const srcMeta = TOOL_META[sourceLabel];
    const dstMeta = TOOL_META[targetLabel];
    if (!srcMeta || !dstMeta) return null;

    const [srcMod, srcSub] = srcMeta;
    const [dstMod, dstSub] = dstMeta;

    // Check cross-modality (account for multi-modality tools like topup)
    const srcMods = srcMod.split('/');
    const dstMods = dstMod.split('/');
    const shareModality = srcMods.some(m => dstMods.includes(m));

    if (!shareModality) {
        return \`Cross-modality: \${srcMods[0]} \\u2192 \${dstMods[0]} is not a standard connection.\`;
    }

    // Same modality but invalid pipeline connection
    if (!_edgeSets.has(sourceLabel)) {
        return \`\${sourceLabel} (\${srcSub}) is a terminal tool with no standard downstream connections.\`;
    }

    return \`No standard pipeline connection from \${srcSub} \\u2192 \${dstSub}.\`;
}
`;

const outPath = path.join(root, 'src/utils/adjacencyValidation.js');
fs.writeFileSync(outPath, output);

const totalEdges = Object.values(edges).reduce((s, v) => s + v.length, 0);
console.log(`Generated ${outPath}`);
console.log(`  ${Object.keys(edges).length} sources, ${totalEdges} edges`);
console.log(`  ${Object.keys(toolMeta).length} tools with metadata`);
console.log(`  ${output.length} chars`);
