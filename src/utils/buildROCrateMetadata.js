/**
 * Build ro-crate-metadata.json content conforming to the
 * Workflow RO-Crate 1.0 profile (https://w3id.org/workflowhub/workflow-ro-crate/1.0).
 *
 * Returns a JSON string â€” no external dependencies needed.
 */

/* ========== URL constants ========== */
const RO_CRATE_SPEC = 'https://w3id.org/ro/crate/1.1';
const RO_CRATE_CONTEXT = `${RO_CRATE_SPEC}/context`;
const WORKFLOW_RO_CRATE_SPEC = 'https://w3id.org/workflowhub/workflow-ro-crate/1.0';
const CWL_SPEC_URL = 'https://w3id.org/cwl/v1.2/';
const CWL_SITE_URL = 'https://www.commonwl.org/';
const MIT_LICENSE_URL = 'https://spdx.org/licenses/MIT';
const DOCKER_HUB_URL = 'https://hub.docker.com/r';
const PYTHON_URL = 'https://www.python.org/';

/* ========== Sub-functions ========== */

/** Build the metadata file descriptor and root dataset entity. */
function buildRootEntities(workflowName, mainWorkflowPath, hasPart) {
    return [
        {
            '@id': 'ro-crate-metadata.json',
            '@type': 'CreativeWork',
            about: { '@id': './' },
            conformsTo: [
                { '@id': RO_CRATE_SPEC },
                { '@id': WORKFLOW_RO_CRATE_SPEC },
            ],
        },
        {
            '@id': './',
            '@type': 'Dataset',
            name: workflowName,
            description: `Neuroimaging CWL workflow generated by niBuild containing ${hasPart.length} part(s).`,
            datePublished: new Date().toISOString().slice(0, 10),
            license: { '@id': MIT_LICENSE_URL },
            mainEntity: { '@id': mainWorkflowPath },
            hasPart,
        },
    ];
}

/** Build the main workflow entity and CWL language contextual entity. */
function buildWorkflowEntity(workflowName, mainWorkflowPath, jobTemplatePath) {
    return [
        {
            '@id': mainWorkflowPath,
            '@type': ['File', 'SoftwareSourceCode', 'ComputationalWorkflow'],
            name: workflowName,
            programmingLanguage: { '@id': '#cwl' },
        },
        {
            '@id': '#cwl',
            '@type': 'ComputerLanguage',
            name: 'Common Workflow Language',
            alternateName: 'CWL',
            identifier: { '@id': CWL_SPEC_URL },
            url: { '@id': CWL_SITE_URL },
        },
        {
            '@id': jobTemplatePath,
            '@type': 'File',
            name: 'Job input template',
            description: 'Pre-configured parameter values for running the workflow',
        },
    ];
}

/** Build entities for individual tool CWL files. */
function buildToolEntities(toolCWLPaths, toolMetadata) {
    return toolCWLPaths.map(p => {
        const meta = toolMetadata[p];
        const entity = {
            '@id': p,
            '@type': ['File', 'SoftwareSourceCode'],
            name: meta?.fullName || p,
            programmingLanguage: { '@id': '#cwl' },
        };
        if (meta?.docUrl) {
            entity.url = { '@id': meta.docUrl };
        }
        return entity;
    });
}

/** Build entities for Docker images. */
function buildDockerEntities(dockerImages) {
    return dockerImages.map(img => {
        const [repo] = img.split(':');
        return {
            '@id': `${DOCKER_HUB_URL}/${repo}`,
            '@type': 'SoftwareApplication',
            name: img,
            url: `${DOCKER_HUB_URL}/${repo}`,
        };
    });
}

/** Build entities for support files (README, Dockerfile, scripts, Singularity). */
function buildSupportEntities(singularityFiles) {
    const entities = [
        {
            '@id': 'README.md',
            '@type': 'File',
            name: 'README',
            encodingFormat: 'text/markdown',
        },
        {
            '@id': 'Dockerfile',
            '@type': 'File',
            name: 'Dockerfile',
            description: 'Orchestration container for Docker-based workflow execution',
        },
        {
            '@id': 'run.sh',
            '@type': 'File',
            name: 'Run script',
            description: 'Entrypoint script with usage help',
        },
        {
            '@id': 'prefetch_images.sh',
            '@type': 'File',
            name: 'Image prefetch script',
            description: 'Pre-pull tool Docker images',
        },
    ];

    if (singularityFiles.length > 0) {
        entities.push(
            {
                '@id': 'Singularity.def',
                '@type': 'File',
                name: 'Singularity definition file',
                description: 'Definition file for building a Singularity/Apptainer orchestration container',
            },
            {
                '@id': 'run_singularity.sh',
                '@type': 'File',
                name: 'Singularity run script',
                description: 'Entrypoint script using cwltool with --singularity flag for HPC execution',
            },
            {
                '@id': 'prefetch_images_singularity.sh',
                '@type': 'File',
                name: 'Singularity image prefetch script',
                description: 'Convert Docker images to Singularity SIF format for offline/HPC use',
            },
        );
    }

    return entities;
}

/** Build entities for BIDS integration files. */
function buildBIDSEntities() {
    return [
        {
            '@id': 'bids_query.json',
            '@type': 'File',
            name: 'BIDS query specification',
            description: 'BIDS input selection parameters for automatic file resolution',
            encodingFormat: 'application/json',
        },
        {
            '@id': 'resolve_bids.py',
            '@type': ['File', 'SoftwareSourceCode'],
            name: 'BIDS resolver script',
            description: 'Resolves BIDS directory structure to concrete CWL job inputs',
            programmingLanguage: { '@id': '#python' },
        },
        {
            '@id': '#python',
            '@type': 'ComputerLanguage',
            name: 'Python',
            url: { '@id': PYTHON_URL },
        },
    ];
}

/* ========== Main export ========== */

/**
 * @param {Object} params
 * @param {string} params.workflowName      - Sanitized workflow name
 * @param {string} params.mainWorkflowPath  - e.g. "workflows/my_pipeline.cwl"
 * @param {string} params.jobTemplatePath   - e.g. "workflows/my_pipeline_job.yml"
 * @param {string[]} params.toolCWLPaths    - e.g. ["cwl/fsl/bet.cwl", ...]
 * @param {Object}  params.toolMetadata     - { [cwlPath]: { fullName, docUrl } }
 * @param {string[]} params.dockerImages    - e.g. ["brainlife/fsl:6.0.5", ...]
 * @param {string[]} params.singularityFiles - e.g. ["Singularity.def", ...]
 * @param {boolean} params.hasBIDS          - Whether BIDS integration is enabled
 * @returns {string} JSON string for ro-crate-metadata.json
 */
export function buildROCrateMetadata({
    workflowName,
    mainWorkflowPath,
    jobTemplatePath,
    toolCWLPaths,
    toolMetadata,
    dockerImages,
    singularityFiles = [],
    hasBIDS = false,
}) {
    const hasPart = [
        { '@id': mainWorkflowPath },
        { '@id': jobTemplatePath },
        { '@id': 'README.md' },
        { '@id': 'Dockerfile' },
        { '@id': 'run.sh' },
        { '@id': 'prefetch_images.sh' },
        ...singularityFiles.map(f => ({ '@id': f })),
        ...toolCWLPaths.map(p => ({ '@id': p })),
        ...(hasBIDS ? [{ '@id': 'bids_query.json' }, { '@id': 'resolve_bids.py' }] : []),
    ];

    const graph = [
        ...buildRootEntities(workflowName, mainWorkflowPath, hasPart),
        ...buildWorkflowEntity(workflowName, mainWorkflowPath, jobTemplatePath),
        ...buildToolEntities(toolCWLPaths, toolMetadata),
        ...buildDockerEntities(dockerImages),
        ...buildSupportEntities(singularityFiles),
        ...(hasBIDS ? buildBIDSEntities() : []),
    ];

    return JSON.stringify(
        {
            '@context': RO_CRATE_CONTEXT,
            '@graph': graph,
        },
        null,
        2
    );
}
